# Система Грамотного Программирования

Система сборки и формат для проектов на основе грамотного программирования.

## Формат

Любой проект на основе основе грамотного программирования — это самодокументирующийся код в формате Википедии. Проект состоит из модулей — файлов в формате `lpnb`. Файлы поддерживают вторичные расширения, например: `main.py.lpnb`. В таком случае, это означает, что после сборки файл должен превратиться в `main.py` и он должен содержать код на языке Питон. Каждый модуль состоит из секций. Секция — это код и документация к нему. Документация должна быть в формате `markdown`, как в Jupyter Notebook. 

Каждый модуль поддерживается в формате `yaml`. Например, см. [пример модуля на языке Питон](./examples/projects/python/main.py.lpnb). В нем `sections` — это обязательное поле для того, чтобы система сборки могла функционировать, а `metadata` — специальное поле для [`UI` на основе Jupyter Notebook](https://github.com/GolubevVA/literate_programming_vscode_extension).

Документация каждой секции должна содержать заголовок в формате `markdown` на первой строке, если эта секция является экспортируемой. По названию модуля и заголовку секции в нем можно ссылаться на другие модули. Например: если в модуле `entry_points/main.py.lpnb` нужно импортировать все сущности из секции под заголовком `# Main App` из модуля `app/app.py.lpnb`, то в `entry_points/main.py.lpnb` в документации подходящей секции можно можно просто сослаться на секцию `# App` в формате Википедии, как это принято делать у `markdown` проектов:

```markdown
Импортируем [Приложение](../app/app#Main-App)
```

После этого, все сущности из `app/app.py.lpnb` можно будет использовать в `entry_points/main.py.lpnb` при наличии соответствующего [Плагина](#Плагины).

Отдельно отметим, что пробелы в заголовках заменяются на дефисы. (Функция `header_to_anchor` в [функциях спецификации](./src/builds/spec/utils.rs)).

Подробнее про формат можно посмотреть в [структурах спецификации](./src/builds/spec/structs.rs).

Дополнительными ограничениями на формат многомодульных проектов являются:
- Запрещено использовать модули с одинаковыми названиями, но разными расширениями, в том числе, если они отличаются только вторичными расширениями. В этом случае работоспособность системы не гарантируется.
- Запрещено использовать сущности с одинаковым названием в проекте, если они могут быть импортированы одновременно. Иначе может произойти коллизия имен.
- Запрещено использовать одинаковые заголовки, даже отличающиеся размером, в рамках одного модуля, так как это создает неоднозначность имени для экспорта.

## Система сборки

Данный репозиторий содержит исходный код утилиты для системы сборки для грамотного программирования. Вся информация об использовании может быть получены через `--help`.

В процессе сборки, проект, основанный на грамотном программировании, собирается в код и документацию к нему.

Если в исходном коде встретились файлы с расширением, отличным от `.lpnb`, они будут скопированы и в исходный код, и в документацию.

### Код

Если в качестве директории целей (`--target-dir`) была выбрана директория `targets`, то собранный код появится в `targets/code/`. Далее его можно запустить или собрать любым удобным способом. Преимущество системы грамотного программирования в ее гибкости и возможно документировать все, включая конфигурацию сборки.

### Документация

Аналогично [Коду](#Код) документация появится в `targets/docs/`. Она будет приведена в формате `Markdown`, что делает ее очень гибкой в возможностям преобразования. Все ссылки (импорты кода) будут преобразованы в ссылки на соответствующие части нужных `.md` файлов.

### Плагины

Плагины используются для того, чтобы систему сборки можно было обобщать на новые языки <i>on-demand</i>. [Примеры плагинов](./examples/plugins/) также доступны для наглядности.

Принципы их работы:
- Каждый раз, когда в файле вида `название.расширение.lpnb` встречается ссылка на какой-то заголовок `другое-название.то-же-расширение.lpnb`, вызывается функция `function get_import_code(current_path, referenced_path_str, code_block)` плагина на языке `lua`, названного как `расширение.lua`. В ней все данные передаются в виде строк, `current_path` — это путь к текущему модулю, который ссылается на модуль `referenced_path_str`. Пути должны быть приведены относительно корневой директории проекта. Третий параметр — это `code_block` — код из секции, на которую ссылается текущий модуль. Плагин должен найти все экспортируемые сущности из этой секции и вернуть строку — код для импорта этих сущностей на необходимом языке. Этот код будет добавлен в начало файла при сборке.
- Для того, чтобы удалять дупбликацию импортов, удалять ненужных импорты или очищать код любыми другими способами, вызывается функция `function clean_code(code)` соответствующего плагина. Ей передается код, полученный сразу после первого этапа сборки. Она должна вернуть очищенный код, без дупликаций импортов, с удалением ненужных импортов и тд. 

Такая система плагинов делает программирование удобнее, позволяет системе оставаться гибкой.

[Примеры](./examples/) призваны продемонстрировать возможности использования этой системы сборки. В них же приведены упрощенные версии плагинов для `Python` и `Node.js`. Плагин для `json` не выполняет значимой функции, но его наличие позволяет [документировать файлы в формате `json`](./examples/projects/python_and_node_js/package.json.lpnb). Дополнительно, в метод `clean_code` плагина можно написать более сложную логику, позволяющую, например, удалять комментарии в `json` в процессе сборки или как-то иначе форматировать его.
